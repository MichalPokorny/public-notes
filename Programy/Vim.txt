Marks:
	`[ = start of pasted text, `] = end of pasted text,
	`[V`]>> indentne pasted text

set diffopt=filler,context=0

g-/g+ = prechod v case +- (jine undo)

set iskeyword-=_ zpusobi, ze _ oddeluje 'slova'

aw = "predchozi slovo"
zz = vertikalne vystred
registr "=": aritmetika
it = inside tag (textovy objekt)

\\(motion) = zakomentuj (pro commentary.vim - plugin)

Editing text at the speed of thought: #52 (75/329)
----------

- YouCompleteMe - podle subsekvence
- Nerd Commenter

- makeprg: muze obsahovat %, ktere se expanduje na soubor
- !!date = na tenhle radek `date`
- :R ls -la = scratchbuffer ls -la
- :Sex = split explore
- va( = vyber vsechno okolo ( vcetne, vi(  vyber vsechno uvnitr ( bez
- :bufdo s/co/naco/ge
- :enew
- ZZ
- Ctrl-F = obrazovka dolu, Ctrl-B = obrazovka nahoru
- 0 = na zacatek radku
- 35| = prejdi na sloupec 35
- Fx = predchozi x, Tx = za predchozi x, ; = opakuj posledni hledani na radku, , = v opacnem smeru
- w, W = zacatek dalsiho,
- }: nejblizsi dalsi konec odstavce
- {: predchozi... (-> 3d})

- U: undo na tomhle radku

- help: Ctrl-] = prejdi, Ctrl-T = zpet

- :set textwidth=80
- gq(pohyb) preformatuje
- {gq} = reformatuj odstavec
- :marks
- '' nebo ``: pred poslednim skokem
- <> = zacatek/konec vizualni oblasti
- C-N, C-P

Medved:
	pomlcka misto mezery pred kterou nic neni
0^$

:set cinoptions

if &term =~ "rxvt"
	set ttymouse=xterm
endif

:scriptnames		show all scripts loaded upon startup
:options
:set patchmode=.orig	save original version
:qall			quit all windows
:wall			save all windows
:s///p			print all changed lines
:/pattern/-1		one line before
:?pattern?		search backward

:...C-D			see completion list

ge			previous word end
W, B, E, gE		the same for whitespace-separated words
t, T			same as f, but stops before the character
zz			center current line on screen
visual:o, O		edit other end (, corner) of selection
"A..Z			append to register (works even when recording)
C-P, C-N		autocomplete previous, next
C-X C-F			autocomplete file name (and many other such tricks)
(ins) C-O		execute a single normal mode command
gj, gk			move by visible lines
/.../e			move to end of matching text (also e+1, e-1 etc.)
/...\_s.../		match space or line break
g?			rot-13
s			the same as cl
S			the same as cc
U			undo all changes on the same line

C-W p			goto previously active window
C-W r/R			rotate windows
[<num>] C-W +/-		increase/decrease window height
[<num>] C-W >/<		increase/decrease window width
<num> C-W _/|		set window height/width
:all			open all edited files in windows
:ball			open all buffers in windows
:windo <cmd>		execute <cmd> in all windows
:bufdo <cmd>		... in all buffers
C-W P			goto preview window
C-W z			close preview window

C-], C-T, C-W ]		find tag, jump back, find tag in other window
C-W }			preview function def in other window
[#, ]#			previous, next CPP construct
[[, ]], ][		prev, next top-level block, end of current
[{, ]}			prev, next block
[(, ])			prev, next subexpression
[/, ]/			start of comment, end of comment
gD, gd			goto definition, only in current function
:cn			next error
:cc			show whole error message

text objects:
a( = a) = ab		a parenthesized block
a< = a>			<...>
aB			{...} block
aW			white-space separated word
a[ = a]			[...]
aw, ap, as		word, paragraph, sentence
i...			inner

autowrite
display=uhex,lastline	(unprintable are shown as <XX>, partial last line shown)

:set spell => [s ]s zg(add to dict) z=(suggest correctly spelled words)

=== POUZIVAM ===
- I = ^i

showmatch		show matching parentheses
list, listchars		highlighting of trailing spaces, tabs etc.
bg=dark
"r <Enter>" je priblizne opak J

vim-commentary
vim-fugitive: blame (Git)

Vim keys: normal -> shift -> control (descending order of frequency) (nebo taky treba &, ...)
vim reference: moving
diw: leave whitespace, daw: kill whitespace
& = repeat replace
Command-T: fuzzy search in Vim
:s, :g
\| v map?
:map xx ...
:silent !echo ...
rails.vim: :A == switch production/test
[m ]m == move by methods in structured language
