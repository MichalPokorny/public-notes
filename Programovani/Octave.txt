1 == 2 (-> false: 0)
1 ~= 2 (to je !=; -> true: 1)
1 && 0
1 || 0

PS1('>> '); (nastavi PS1)

a = 3;  % semicolon: zabije vypis
b = 'hi';
c = (3>=1); % c = 1 (true)
a = pi;
disp(a);
disp(sprintf('2 decimals: %0.2f', a));

format long / format short: dlouhy nebo kratky vypis

A = [1 2; 3 4; 5 6] % (3 radky, 2 sloupce)
v = [1 2 3] % row vector
j = [1;2;3] % column vector

v = 1:0.1:2 % range: zacatek 1, step 0.1, konec 2 vcetne

ones(2,3); % 2 radky, 3 sloupce; taky zeroes, rand

randn(1,3); % Gaussian

w = sqrt(10) * randn(1,10000)
hist(w) % histogram

eye(5) % identita

help eye

A = [1 2;3 4;5 6]
size(A) % vrati 3 2
size(A,1) % vrati pocet radku: 3
length([1 2 3 4 5]) % 5; nebo length([1;2;3;4;5])

pwd
cd ...

load featuresX.dat
load priceY.dat
% (nebo load('featureX.dat');)

who % jake promenne mam ve workspacu; taky "whos"

clear X % zabije tu promennou
priceX(1:10) % range vektoru
save hello.mat v % ulozi v
clear % zabije vsechno

save hello.txt v -ascii % ASCII format, ne binarni

A=[1 2;3 4;5 6]
A(:,2) -> druhy sloupec
A(1,:) -> prvni radek

A = [A, [100; 101; 102]] % prida sloupec

nasobeni matic: A * C
elementwise: A .* B
elementwise square: A .^ 2

v = [1;2;3]
1 [[./]] v -> elementwise reciprocal

v+1: elementwise pridat 1

A' % transpose

max(a); min(a); avg(a);

[val, ind] = max(a); % val = hodnota, ind = index; na matici columnwise maximum

a = [1 2 3 4]
a < 3 -> [1 1 0 0]

find(a<3) -> vrati vektor mist, kde je to <3
magic(3): magic square

[r,c] = find(A>=7), kde A=magic(3):
vrati pary row-column
prod(a): produkt
floor(a), ceil(a)

max(A,B): matice s maximy z elementu A a B
max(A,[],1): maxima ze sloupcu
max(A,[],2): rowwise

A(:) zvektorizuje matici

flipud: vertikalni flip
pinv(A): pseudoinverz

for i = 1:10
	disp("Ahoj!");
endfor

nahodna matice: rand(5,5).
