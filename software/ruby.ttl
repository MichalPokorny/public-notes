@prefix : <http://rny.cz/knowledge#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

:ruby rdfs:label "Ruby".

("rubycritic") :under :ruby .
("array decomposition in method args") :under :ruby .
("TODO: guard") :under :ruby .

:ruby :note """
Proc.new si muze ukradnout muj blok... neee :D
	sometimes_block { puts "Hi" }
	sometimes_block

	def sometimes_block; if block_given?; Proc.new.call; end; end

Pomale operace:
	:predicate? â†’ lepsi zaaliasovat nez definovat
	lambda je pomala: musi si pamatovat environment
	define_method: pomale, pouziva to block

TODO: naucit se jak funguje Benchmark (nazpamet)

- def x(*); super; end -- tohle je asi jedine uzitecne pouziti anonymniho splatu...

- Nemusim byt jediny, kdo pretezuje method_missing. Musim volat super. (podobne pri respond_to?)

- slideshow gem

- 2D fyzika: chipmunk-physics. ma to Ruby FFI bindingy.

- rack-middleware_profiler: profiluje jako middleware
- memprof: memory profiling

- od 2.1.0 jde out-of-band garbage collection (to mozna umozni delat gc mezi requesty)

FactoryGirl.lint pred vsemi testy!

- hash: default_proc (da se predat v konstruktoru)

- bbatsov/ruby-style-guide
- rubocop

acts_as_tree; acts_as_nested_set
Rails RJS: generovani templatu na zmeny elementu stranky! :D
^^ (Rails)
assert_valid_markup test helper
ActiveRecord calculations

Rails services

%i: symbol array syntax

rspec: its("phone_numbers.size") { should == 2 }
its([:key]) { should eq(value) }: na hashe
TODO: jak RSpec dela, ze jde udelat 'def'?
TODO: rspec: shared context = ?
fuubar: instafailing rspec progress bar formatter

benchmark/ips
benchmark: standard library (naucit se!)
ips: iterations/second -- pocita kolikrat se to stihne za sekundu
stackprof
GC.stat()
GC.stat(:total_allocated_object)
allocation_tracer gem
find(1), find([1]), find([[1]]), find({1 => 1}), find(post), find(1) { ... } (???), scoping { find } -- NAUCIT SE, zni to hezky
TracePoint(:c_call, :call) a podobne
html_safe subclasses String

begin -- rescue -- else

extend = to same jako include, ale na singleton class

next = break block, break = out of iterator invoking block, return returns

.method(:...).source_location

trailblazerb.org ("more opinionated Rails")
array.lazy

"-run": umi spoustu veci (modul 'un')

... .lazy.map
{ |x| a(x) } ==> each(&method(:a))
Process.daemon
YAML::Store :)
stub.as_null_object => muze vse

gem stringex
""" .
